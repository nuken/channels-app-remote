<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Channels App Remote Control</title>
    <style>
        body { font-family: sans-serif; margin: 20px; background-color: #f4f4f4; color: #333; }
        .container { max-width: 800px; margin: 0 auto; background-color: #fff; padding: 25px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        h1, h2 { color: #0056b3; }
        .config-info { background-color: #e9ecef; padding: 10px; border-radius: 5px; margin-bottom: 20px; font-size: 0.9em; }
        .button-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(135px, 1fr));
            gap: 10px;
            margin-bottom: 20px;
        }
        button {
            padding: 12px 15px;
            font-size: 1em;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s ease;
            white-space: nowrap;
        }
        button:hover { background-color: #0056b3; }
        button:active { background-color: #004085; }
        button:disabled { background-color: #cccccc; cursor: not-allowed; }

        .input-group { margin-top: 15px; display: flex; gap: 10px; align-items: center; }
        .input-group input {
            padding: 10px;
            font-size: 1em;
            border: 1px solid #ccc;
            border-radius: 5px;
            flex-grow: 1;
        }

        #seek_amount_input {
            width: 70px;
            text-align: center;
            -moz-appearance: textfield;
            flex-grow: 0;
        }
        #seek_amount_input::-webkit-outer-spin-button,
        #seek_amount_input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        #manual_channel_input {
            min-width: 120px;
        }

        pre {
            background-color: #e9ecef;
            padding: 15px;
            border-radius: 5px;
            white-space: pre-wrap;
            word-wrap: break-word;
            font-size: 0.85em;
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #dee2e6;
        }
        .status-section { margin-top: 25px; }
        .channel-list-section { margin-top: 25px; }
        .channel-list-section select { width: 100%; padding: 10px; border-radius: 5px; border: 1px solid #ccc; font-size: 1em; margin-bottom: 10px;}
        .channel-list-section .refresh-button-container { text-align: right; margin-top: 5px; }
        .seek-controls { margin-top: 15px; }

        /* Notification Styling */
        #notification-area {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-width: 300px;
        }
        .notification {
            background-color: #4CAF50;
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            font-size: 0.9em;
        }
        .notification.error { background-color: #f44336; }
        .notification.show { opacity: 1; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Channels App Remote Control</h1>

        <div class="config-info">
            <p><strong>Configured Clients:</strong></p>
            <select id="client-select" onchange="selectClient()">
                <option value="">Select a Client</option>
                {% for client in clients %}
                    <option value="{{ client.ip }}">{{ client.name }} ({{ client.ip }})</option>
                {% endfor %}
            </select>
            {% if not clients_configured %}
                <p style="color: red;">No clients configured. Set CHANNELS_APP_CLIENTS environment variable.</p>
            {% endif %}
        </div>

        <div style="margin-bottom: 20px;">
            <input type="checkbox" id="enablePopups" checked>
            <label for="enablePopups">Show Status Notifications (Recommended: Off for mobile)</label>
        </div>


        <h2>Playback Controls</h2>
        <div class="button-grid">
            <button class="control-button" onclick="sendCommand('toggle_pause')">Play/Pause</button>
            <button class="control-button" onclick="sendCommand('stop')">Stop Playback</button>
            <button class="control-button" onclick="sendCommand('toggle_mute')">Toggle Mute</button>
            <button class="control-button" onclick="sendCommand('toggle_cc')">Toggle CC</button>
            <button class="control-button" onclick="toggleCcAndMute()">CC + Mute Toggle</button>
            <button class="control-button" onclick="rewindAndEnableCC()">Rewind 15s & CC</button>
            <button class="control-button" onclick="sendCommand('channel_up')">Channel Up</button>
            <button class="control-button" onclick="sendCommand('channel_down')">Channel Down</button>
            <button class="control-button" onclick="sendCommand('previous_channel')">Previous Channel</button>
        </div>

        <div class="seek-controls input-group">
            <input type="number" id="seek_amount_input" value="30" placeholder="Secs"> <button class="control-button" onclick="sendSeekCommand(-1 * document.getElementById('seek_amount_input').value)">Seek Back</button>
            <button class="control-button" onclick="sendSeekCommand(document.getElementById('seek_amount_input').value)">Seek Forward</button>
        </div>

        <div class="input-group">
            <input type="number" id="manual_channel_input" placeholder="Enter Channel #"> <button class="control-button" onclick="sendCommand('play_channel', document.getElementById('manual_channel_input').value)">Play Manual Channel</button>
        </div>

        <div class="channel-list-section">
            <h2>Live TV Favorite Channels</h2>
            <select id="channel-select" class="control-button" onchange="tuneToSelectedChannel()">
                <option value="">Select a Channel</option>
                </select>
            <div class="refresh-button-container">
                <button class="control-button" onclick="loadChannels()">Refresh Favorites</button>
            </div>
            <p style="font-size: 0.8em; margin-top: 5px;">Fetches favorite channels directly from the selected Channels App client.</p>
        </div>


        <h2>Navigation</h2>
        <div class="button-grid">
            <button class="control-button" onclick="sendCommand('navigate', 'Live TV')">Go to Live TV</button>
            <button class="control-button" onclick="sendCommand('navigate', 'Guide')">Go to Guide</button>
            <button class="control-button" onclick="sendCommand('navigate', 'Library')">Go to Library</button>
            <button class="control-button" onclick="sendCommand('navigate', 'Search')">Go to Search</button>
        </div>

        <div class="status-section">
            <h2>Current Device Status</h2>
            <button class="control-button" onclick="getStatus()">Refresh Status</button>
            <pre id="status-display">Select a client and click "Refresh Status" to fetch.</pre>
        </div>
    </div>

    <div id="notification-area"></div>

    <script>
        const clientSelect = document.getElementById('client-select');
        const channelSelect = document.getElementById('channel-select');
        const enablePopupsCheckbox = document.getElementById('enablePopups');
        const notificationArea = document.getElementById('notification-area');
        const statusDisplay = document.getElementById('status-display');
        const controlButtons = document.querySelectorAll('.control-button');

        let selectedClientIp = '';

        // These variables are now correctly populated by Flask again
        const flaskClients = {{ clients | tojson }};
        const clientsConfiguredViaEnv = {{ clients_configured | tojson }};


        function showNotification(message, isError = false) {
            if (!enablePopupsCheckbox.checked) {
                console.log("Notification suppressed:", message);
                return;
            }
            const notification = document.createElement('div');
            notification.className = `notification ${isError ? 'error' : ''}`;
            notification.textContent = message;
            notificationArea.appendChild(notification);

            void notification.offsetWidth;
            notification.classList.add('show');

            setTimeout(() => {
                notification.classList.remove('show');
                notification.addEventListener('transitionend', () => notification.remove(), { once: true });
            }, 3000);
        }

        function toggleControls(enable) {
            controlButtons.forEach(button => {
                button.disabled = !enable;
            });
            if (enable && selectedClientIp) {
                channelSelect.disabled = false;
            } else {
                channelSelect.disabled = true;
            }
        }

        // Initialize state based on initial client selection
        document.addEventListener('DOMContentLoaded', () => {
            // Restore saved popup state
            const savedPopupState = localStorage.getItem('enablePopups');
            if (savedPopupState !== null) {
                enablePopupsCheckbox.checked = JSON.parse(savedPopupState);
            } else {
                enablePopupsCheckbox.checked = false; // Default to off
            }

            enablePopupsCheckbox.addEventListener('change', () => {
                localStorage.setItem('enablePopups', enablePopupsCheckbox.checked);
            });

            // Handle client selection based on flaskClients
            if (flaskClients.length > 0) { // If there's at least one client from environment variable
                clientSelect.selectedIndex = 1; // Auto-select the first client (index 0 is "Select a Client")
                selectClient(); // Trigger the selection logic
            } else {
                toggleControls(false); // Disable controls if no clients are configured
                statusDisplay.innerText = "No Channels App clients configured. Please set CHANNELS_APP_CLIENTS environment variable.";
                showNotification("No Channels App clients configured.", true);
            }
        });

        async function selectClient() {
            selectedClientIp = clientSelect.value;
            if (selectedClientIp) {
                showNotification(`Controlling: ${clientSelect.options[clientSelect.selectedIndex].text}`, false);
                toggleControls(true); // Enable controls when a client is selected
                getStatus(); // Get status of the newly selected client
                loadChannels(); // Load favorite channels for the newly selected client
            } else {
                showNotification("Please select a client device.", true);
                toggleControls(false); // Disable controls if no client is selected
                statusDisplay.innerText = "Select a client and click \"Refresh Status\" to fetch.";
                channelSelect.innerHTML = '<option value="">Select a Client First</option>';
            }
        }

        async function sendCommand(action, value = null) {
            if (!selectedClientIp) {
                showNotification("Please select a client device first.", true);
                return 'error';
            }

            const data = { action: action, device_ip: selectedClientIp };
            if (value !== null) {
                data.value = value;
            }

            try {
                const response = await fetch('/control', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(data)
                });
                const result = await response.json();
                showNotification(`Action '${action}': ${result.message}`, result.status === 'error');
                getStatus();
                return result.status;
            } catch (error) {
                showNotification(`Error sending command: ${error.message}`, true);
                return 'error';
            }
        }

        async function sendSeekCommand(amount) {
            if (!selectedClientIp) {
                showNotification("Please select a client device first.", true);
                return 'error';
            }
            const seekValue = parseInt(amount, 10);
            if (isNaN(seekValue)) {
                showNotification("Please enter a valid number for seek amount.", true);
                return 'error';
            }

            const data = { action: 'seek', device_ip: selectedClientIp, seek_amount: seekValue };

            try {
                const response = await fetch('/control', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(data)
                });
                const result = await response.json();
                showNotification(`Seek ${seekValue}s: ${result.message}`, result.status === 'error');
                getStatus();
                return result.status;
            } catch (error) {
                showNotification(`Error sending seek command: ${error.message}`, true);
                return 'error';
            }
        }

        async function toggleCcAndMute() {
            if (!selectedClientIp) {
                showNotification("Please select a client device first.", true);
                return;
            }

            const ccStatus = await sendCommand('toggle_cc');
            if (ccStatus === 'error') {
                showNotification("Failed to toggle Closed Captions.", true);
                return;
            }

            const muteStatus = await sendCommand('toggle_mute');
            if (muteStatus === 'error') {
                showNotification("Failed to toggle Mute.", true);
                return;
            }

            if (ccStatus === 'success' && muteStatus === 'success') {
                showNotification("Closed Captions and Mute toggled successfully.", false);
            }
        }

        async function rewindAndEnableCC() {
            if (!selectedClientIp) {
                showNotification("Please select a client device first.", true);
                return;
            }

            const seekStatus = await sendSeekCommand(-15);
            if (seekStatus === 'error') {
                showNotification("Failed to rewind.", true);
                return;
            }

            const ccToggleStatus = await sendCommand('toggle_cc');
            if (ccToggleStatus === 'success') {
                showNotification("Rewound 15s and Closed Captions toggled.", false);
            } else {
                showNotification("Rewound 15s, but failed to toggle Closed Captions.", true);
            }
        }

        async function getStatus() {
            if (!selectedClientIp) {
                statusDisplay.innerText = "No client selected.";
                return;
            }
            try {
                const response = await fetch(`/status?device_ip=${selectedClientIp}`);
                const status = await response.json();
                if (status.status === 'error') {
                    statusDisplay.innerText = `Error: ${status.message}`;
                    showNotification(`Status Error: ${status.message}`, true);
                } else {
                    statusDisplay.innerText = JSON.stringify(status, null, 2);
                    showNotification(`Status refreshed for ${selectedClientIp}.`, false);
                }
            } catch (error) {
                statusDisplay.innerText = `Error fetching status: ${error.message}\nEnsure the Channels App is running on ${selectedClientIp} and reachable.`;
                showNotification(`Status fetch error for ${selectedClientIp}: ${error.message}`, true);
            }
        }

        async function loadChannels() {
            if (!selectedClientIp) {
                channelSelect.innerHTML = '<option value="">Select a Client First</option>';
                channelSelect.disabled = true;
                return;
            }

            channelSelect.innerHTML = '<option value="">Loading Channels...</option>';
            channelSelect.disabled = true;

            try {
                const response = await fetch(`/channels_list?device_ip=${selectedClientIp}`);
                const channels = await response.json();

                channelSelect.innerHTML = '<option value="">Select a Channel</option>';

                if (channels.status === 'error') {
                    showNotification(`Failed to load favorite channels: ${channels.message}`, true);
                    channelSelect.innerHTML = `<option value="">Error: ${channels.message}</option>`;
                } else if (channels.length === 0) {
                     channelSelect.innerHTML = '<option value="">No favorite channels found.</option>';
                } else {
                    channels.forEach(channel => {
                        const option = document.createElement('option');
                        option.value = channel.channel_number;
                        option.textContent = `${channel.channel_number} - ${channel.name}`;
                        channelSelect.appendChild(option);
                    });
                    channelSelect.disabled = false;
                    showNotification(`Favorite channels loaded for ${selectedClientIp}.`, false);
                }

            } catch (error) {
                showNotification(`Failed to fetch favorite channel list: ${error.message}`, true);
                channelSelect.innerHTML = '<option value="">Failed to load channels.</option>';
            }
        }

        function tuneToSelectedChannel() {
            const selectedChannel = channelSelect.value;
            if (selectedChannel) {
                sendCommand('play_channel', selectedChannel);
            }
        }
    </script>
</body>
</html>